agent:
  instance_template: ""
  action_observation_template: ""
  system_template: ""
  general_input: |
    You are an interactive debugging assistant that iteratively interacts with a computer shell to solve programming tasks. Your objective is to identify the root cause of a software issue and resolve it efficiently and systematically.

    {{task_description}}

    {{tool_usage}}

    # Input
    You are provided with the following information:
    - *Code Context*. This section contains all code snippets accessed during previous debugging operations. These snippets are up-to-date and reflect the modifications made during previous debugging operations. **Note**: Do not retrieve code snippets that are already present in the Code Context.
    - *Rejected Operations and Lessons Learned*. This section tracks unsuccessful debugging operations. It lists proposed operations that failed to yield useful observations due to incorrect tool usage or retrieval errors. Each entry includes lessons to help you avoid repeating these mistakes.
    - *Code Changes*. This section shows a cumulative diff comparing the current state of the codebase to the original version. This provides a clear view of the modifications made so far.
    - *Operation History and Reasoning Chain*. This section lists the sequence of **successful** operations since the debugging task began. Each operation retrieves useful information that contributes to the reasoning chain leading to resolving the issue.
    {%- if incoming_op %}
    - *Incoming Operation*. This describes the action and observation of an incoming new action.
    {% endif -%}
  reflection_instructions: |
    # Rethink the incoming operation
    Your are expected to determine whether the observations from the incoming operation help reveal the root cause of the software issue, based on the reasoning chain constructed from the successful operations in the Operation History and Reasoning Chain section.
      - If the new operation successfully retrieves the expected information and contributes to identifying the root cause of the software issue, **accept** the incoming operation in the reasoning chain.
      - If the operation crashes, malfunctions, or fails to execute properly, or the observations do not contain the expected information and do not contribute to identifying the root cause, **reject** the operation.
    Enclose your decision within a pair of `<decision></decision>` tags.

    Write a concise summary of the current reasoning chain, incorporating the contribution of the incoming operation. Describe the key findings and evidence gathered across all successful operations so far, how they connect to form the current understanding of the root cause, and what the incoming operation added to or changed about this understanding. Enclose the summary within a pair of `<summary></summary>` tags.

    Finally, extract the lessons learned from the incoming operation if you decide to **reject** it. For example, explain why the command malfunctioned and how to avoid similar issues, or why the observation did not provide useful evidence and what should be avoided in future debugging operations. Place the lessons within a single pair of `<lessons></lessons>` tags.
  action_instructions: |    
    # Propose a new action
    Following the instructions of systematic debugging, propose the next operation based on the existing ones in the Operation History and Reasoning Chain section. To accomplish this task, you should:
      1. Strictly follow the steps of systematic debugging. Try to infer the root cause of the issue based on their observations, and identify what additional information is still needed to confirm it.
      2. Refer to the Code Context section to read relevant code snippets. Do not repeatedly access snippets that are already included there. The Code Context already reflects the latest modifications from previous operations. Use the Current Code Change section to see how the source code has been modified.
      3. Refer to the rejected operations and the lessons learned from them. Make sure your proposed new operation avoids making the same mistakes.
      4. Carefully read the usage instructions, examples, and "pro tips" for the available tools, and choose the most appropriate one to accomplish your objective. Specifically, you must use the `get_code_context` tool to access code snippets. If you use common bash commands such as `cat` or `nl`, the retrieved code will not be added to the Code Context section.
    You may choose to *complete editing* once you are confident that all faulty code snippets have been corrected and the reproduction script executes without errors.
    Execute *one action* in each operation. Put the command of the action command inside a pair of `<action></action>` tags.

    Consider how your proposed operation contributes to the reasoning chain built from the existing successful operations. Classify the operation as either `exploitative` or `exploratory`:
      - An operation is **exploitative** if it attempts to validate the current hypothesis by gathering additional evidence grounded in prior observations. For example, if you suspected an issue with a function's behavior in a previous operation, and you now propose to collect more evidence to confirm or refute that suspicion, the operation is exploitative.
      - An operation is **exploratory** if it selects one direction among multiple plausible alternatives in order to reduce uncertainty. For example, if you identify several functions as potentially suspicious and decide to begin investigating one of them, that operation is exploratory.
    Enclose the classification of your proposed operation between a pair of `<property></property>` tags.

    Write a few sentences explaining why you chose to take this action. Enclose your reasoning within a pair of `<thoughts></thoughts>` tags.
  response_format: |
    # Response Format
    Strictly follow the response format listed below:

    ```
    {% if incoming_op -%}
    # Rethink the incoming action
    <decision>accept or reject</decision>
    <summary>summary of the reasoning chain</summary>
    <lessons>lessions learned if decided to reject</lessons>

    {% endif %}
    # Propose a new action
    <property>exploitative or exploratory</property>
    <thoughts>your thoughts</thoughts>
    <action>action command</action>
    ```
  incoming_operation_template: |
    # Incoming Operation

    ## Thoughts
    {{thoughts}}

    ## Action and Observation
    {% for obs in observation -%}
    [action] {{obs.action}}
    [observation]
    ```
    {{obs.observation}}
    ```

    {% endfor -%}
    {% if accessed_code -%}
    ## Accessed Code Snippets
    The following code snippets are accessed during this operation:

    {{accessed_code}}
    {%- endif %}

    ## Incoming Code Change
    {% if incoming_code_change %}
    The code changes in the current workspace were updated during this operation:

    ```diff
    {{incoming_code_change}}
    ```
    {%- else -%}
    No code change was made during the incoming operation.
    If you intended to make code change, your action may have failed.
    {%- endif %}
  format_error_template: |
    Your response was not in the expected format. Please use the XML tags specified in the response format section.
  timeout_template: |
    The last command timed out and has been killed.
    {% if output | length < 10000 -%}
    <output>
    {{output}}
    </output>
    {%- else -%}
    <output_head>{{ output[:5000] }}</output_head>
    <elided_chars>{{ output | length - 10000 }} characters elided</elided_chars>
    <output_tail>{{ output[-5000:] }}</output_tail>
    {%- endif %}
    Please try a different approach.
  step_limit: 250
  cost_limit: 3.0
  task_description_template: |
    # Task description

    ## Software Issue
    Consider the following Pull Request (PR) Description:
    ```
    {{task}}
    ```

    ## Reproduction Script
    A script demonstrating the issue is available at `{{ script_location }}`.

    You can run it with:
    <action>
    {{ script_command }}
    <action>

    The output of this script is as follows:
    ```
    {{ script_output }}
    ```

    ## Task Instructions
    ### Overview
    You're a software engineer interacting continuously with a computer by running commands. Your task is to systematically debug the issue described in the PR description with the reproduction script. Your goal is specifically to make changes to non-test files in the current directory in order to fix the issue described in the PR description in a way that is general and consistent with the codebase.
    
    {{subtask_instructions}}
  systematic_debugging_instructions_template: |
    ### Workflow
    Strictly follow the steps outlined below to conduct a systematic debugging process.

    1. Identify the incorrect value that causes the script to fail by examining the error message or stack trace.
    i) Assertion failure.  
    Inspect the function call that produces the incorrect output.  
    Example: consider the following script:
    ```python
       ...
    8  result = foo(input)
    9  assert result == expected      # Assertion failure here!
    ```
    The function `foo` produces an incorrect result, which eventually causes the script to fail. As the first step in debugging, *step in* at line 8 to investigate why it returns an unexpected value.

    ii) Unhandled exception.
    Investigate the code context near the line where the exception is raised.
    Example: consider the following stack trace template:
    ```
    Traceback (most recent call last):
      File "issue_reproduction.py", line 9, in <module>
      result = foo(...)
      ... (intermediate frames omitted)
      File "utils.py", line 74, in bar
      return a / b
    ZeroDivisionError: division by zero
    ```
    The last frame of the stack trace indicates that the exception is raised at `utils.py:74`. However, this location is often not the root cause. As the first step in debugging, examine the code around this line to find out why the variables (`a` and `b`) are assigned unexpected values.

    2. From there, trace backward through the relevant statements and step into the function calls that influence the incorrect value. Build a clear and logically consistent reasoning chain that identifies where the buggy value is introduced, how it propagates through the program, and why it ultimately triggers the failure.

    For any suspicious code snippet you encounter, examine it in the following steps:
    i)   What are the inputs to this snippet?  
    ii)  What is the actual output it produces?  
    iii) Does this output match the intended functionality and specification?
    If the behavior does not match what the code is supposed to do, the bug is likely within this snippet. Identify what the correct behavior should be, and modify the code so that its output aligns with the intended logic.

    For example, consider the following code snippet:
    File: `experiment.py`
    ```python
        ...
    73  progress = build_progress(input)
    74  res = '\n'.join(progress[:-1])
    75  return res                 # The return value is wrong!
    ```

    To investigate why line 75 returns the wrong value `res`, start by examining line 74. Specifically, investigate the following runtime values:
    - The value of `progress` at line 74 (the input to the statement).
    - The value of `res` at line 75 (the output of line 74).
    Then try to answer: does `'\n'.join(progress[:-1])` correctly implement the intended logic?
    If the relationship between the input (`progress`) and the output (`res`) does not match the expected behavior, then the bug likely lies in line 74. 
    If you believe the value of `progress` is still suspicious, continue tracing backward. You may want to step into function `build_progress` to investigate whether if this function correctly computes the output given the input value.

    3. Repeat step 2 until you find the *root cause* of the bug â€”- the earliest code snippet in the execution trace that produces an incorrect value. 
    Note that a buggy program may involve *multiple* buggy locations. Stop tracing if you can confirm the upstream code logic is performing correctly and does not introduce wrong runtime values.

    ### Techniques
    Make sure you use the techniques provided in this section to help you debug systematically.

    1. Stepping into a function call
    To inspect a function call precisely, you are recommended to operate the debugger to set up a breakpoint at the call site, stop at the breakpoint, and step into the function call. Once you have stepped into the target function, print out the current call stack using the "where" command, and the surrounding code context using "list .".
    Example: `debugger-commands "b issue_reproduction.py:5" "c" "step" "where" "list ."`

    You can restart the debugger to the beginning of the program with `debugger-commands "restart"`. The breakpoints will be cleared.

    2. Investigating a runtime value
    It is practical to operate the debugger to stop at line X and print out the value of a valid expression with a `print(...)` statement. The printed value reflects the runtime state *before* line X is executed. 

    The debugger toolbox also provides a shortcut `debugger-lookup-value` to help you with this. Sometimes you may want to investigate a runtime value within a loop structure. This command will output the value of every iteration if the line is executed multiple times. Note that the value will be collected **before** the line of code is executed.
    Usage: `debugger-lookup-value <file_path> <line_number> <expression>`

    ### Important Notes
    1. During debugging, you should modify the source code in this repository so that the reproduction script passes without failure.
    You should *NOT*:
      - Modify the reproduction script to make it pass, or
      - Modify existing tests to make them pass, or
      - Modify configuration files (e.g., pyproject.toml, setup.cfg, tox.ini).
    
    2. Debug rigrously. Do not agressively read a large chunk of code content and make decision without investigating runtime values. Make sure each step of your decision is grounded by the reasoning chain constructed with previous findings.
  code_context_template: |
    # Code Context

    {% if code_context -%}
    This section contains all code snippets accessed during previous debugging operations. These snippets are up-to-date and reflect the modifications made during previous debugging operations.

    {{code_context}}
    {%- else -%}
    No code context loaded yet.
    {%- endif %}
  operation_history_template: |
    # Operation History and Reasoning Chain
    {% if reasoning_chain -%}
    This section lists the sequence of **successful** operations since the debugging task began. Each operation retrieves useful information that contributes to the reasoning chain leading to resolving the issue.

    {% for node in reasoning_chain -%}
    ## Operation {{loop.index}}

    ### Thoughts

    {{node.thoughts}}

    {% if node.observations %}
    ### Action and Observation

    {% for obs in node.observations -%}
    [action] {{obs.action}}
    [observation]
    ```
    {% if obs.observation | length > 5000 -%}
    {{obs.observation[:2000]}}
    ... ({{obs.observation | length - 4000}} chars elided) ...
    {{obs.observation[-2000:]}}
    {%- else -%}
    {{obs.observation}}
    {%- endif %}
    ```

    {%- endfor -%}
    {%- endif -%}
    {% if node.dead_path_summaries %}

    ### Dead Paths
    {% for s in node.dead_path_summaries -%}
    - {{s}}
    {% endfor -%}
    {%- endif %}

    {% endfor -%}
    {%- if reasoning_chain[-1].summary -%}
    ## Reasoning Chain Summary

    {{reasoning_chain[-1].summary}}
    {%- endif -%}
    {%- else -%}
    No operations performed yet.
    {%- endif %}
  version_control_template: |
    ## Current Code Change
    {% if current_node and current_node.code_change -%}
    The following diff represents the current state of code modifications relative to the original version of the codebase:

    ```diff
    {{current_node.code_change}}
    ```

    The code snippets in the `Code Context` section already reflect this latest version.
    Review these changes carefully before proposing your next action. Any new modifications must remain consistent with and build upon the existing changes.
    {%- else -%}
    No code changes have been made so far.
    {%- endif %}
  tool_usage_template: |
    # Available Tools

    {% if installed_tools -%}
    {% for tool in installed_tools -%}
    ## {{ tool.name | capitalize }}
    {{ tool.help }}
    {% if tool.status is not none %}

    ### {{ tool.name | capitalize }} Tool Status
    {% for key, value in tool.status.items() -%}
    - {{ key | capitalize }}
    {{ value if value else "None" }}
    
    {% endfor -%}
    {%- endif %}

    {% endfor -%}
    {%- endif -%}
    ## Code Context Loader
    Load code snippets into code context.

    ### Available commands

    1. get-nearby-code-context: Load the code contexts from a file surrounding a line.

    Usage: `get-nearby-code-context <file_path> <line_number>`
    Provide exactly **one** line number. 
    If the line is inside a function shorter than 100 lines, the tool loads the entire function; otherwise, it loads the surrounding 100 lines of code.
    
    2. get-code-lines: Load the code context from a file using the specified start and end line numbers.

    Usage: `get-code-lines <file_path> <start> <end>`
    Provide **two** line numbers (start and end), seperated by space. The tool loads the code within the given range.

    ## Bash

    Execute any other shell commands.

    Usage: `<any shell command>`
    Examples: edit files with `sed`
      - `sed -i 's/old_string/new_string/g' filename.py` # Replace all occurrences
      - `sed -i 's/old_string/new_string/' filename.py` # Replace only first occurrence
      - `sed -i '1s/old_string/new_string/' filename.py` # Replace first occurrence on line 1
      - `sed -i '1,10s/old_string/new_string/g' filename.py` # Replace all occurrences in lines 1-10

    Warning:
      - **DO NOT USE** common unix shell commands (e.g. `cat`, `nl`) to read large chunks of file contents. Make sure you use the tool `get_code_context` so that the accessed code context will be loaded into the Code Context section.
      - Use common unix shell commands when no existing tool can achieve the same objective. For example, if the provided code search tools failed to work, use `grep -n` to search for specific code snippets.

    ## Complete Editing
    When you have completed your changes, submit with:
    ```
    echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT && git add -A && git diff --cached
    ```
  rejected_operations_template: |
    # Rejected Operations and Lessons Learned
    {%- if rejected_actions %}

    The following actions were previously attempted but rejected. Avoid repeating similar mistakes.

    {% for node in rejected_actions -%}
    ## Rejected Operation {{loop.index}}

    ### Action and Observation
    {% for obs in node.observations -%}
    [action] {{obs.action}}
    [observation]
    ```
    {% if obs.observation | length > 3000 -%}
    {{obs.observation[:1000]}}
    ... ({{obs.observation | length - 2000}} chars elided) ...
    {{obs.observation[-1000:]}}
    {%- else -%}
    {{obs.observation}}
    {%- endif %}
    ```

    {% endfor -%}
    {% if node.lessons %}
    ### Lessons Learned
    {{node.lessons}}

    {% endif -%}
    {%- endfor -%}
    {%- endif -%}
  max_invalid: 10
  history_output_path: "/home/ruixinw/debugmaster_artifact/aclarr_experiments/experiments_output/traj_readable/llm_ide"

environment:
  cwd: "/testbed"
  timeout: 300
  env:
    PAGER: cat
    MANPAGER: cat
    LESS: -R
    PIP_PROGRESS_BAR: 'off'
    TQDM_DISABLE: '1'
  environment_class: docker

  reproduction_complete: True
  reproduction_script:
    source_dir: "/home/ruixinw/debugmaster_artifact/aclarr_experiments/swebench-reproduction_scripts"
    target: "/testbed/issue_reproduction.py"

  tools:
    - debugger
    - navigator
  tool_vars:
    debugger:
      debugger_default_task: "/testbed/issue_reproduction.py"
    navigator:
      cwd: "/testbed"

model:
  model_name: "openai/gpt-5-mini"
  model_kwargs:
    drop_params: true
    temperature: 0.0
    reasoning_effort: "medium"
